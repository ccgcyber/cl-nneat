(in-package :nneat-animals)

(defclass scavenger (animal)
  ((dead-x :accessor scavenger-dead-x)
   (dead-y :accessor scavenger-dead-y)))

(defmethod process-outputs ((animal scavenger) objects outputs)
  (if *neuron-sigmoid-negatives*
      (progn
        (incf (angle animal) (* *angle-multiplier* (car outputs)))
        (setf (speed animal) (cadr outputs)))
      (progn
        (incf (angle animal) (* (* 2 (- (car outputs) 1/2)) *angle-multiplier*))
        (setf (speed animal) (cadr outputs))));(1- (* 2 (cadr outputs))))))
  (eat animal (get-nearest-object (x animal)
                                  (y animal)
                                  (get-objects-of-type objects 'food))))

#|
(defmethod run_ ((animal scavenger) (objects vector))
  (let ((food (get-objects-of-type objects 'food))
        (predators (get-objects-of-type objects 'predator))
        (x (x animal))
        (y (y animal)))
    (let* ((nearest-food (get-nearest-object x y food))
           (nearest-predator (get-nearest-object x y predators))
           (fx (x nearest-food))
           (fy (y nearest-food))
           (px (x nearest-predator))
           (py (y nearest-predator))
           (animal-angle (angle animal))
           (food-angle-diff (/ (angle-diff x y fx fy animal-angle) 90))
           (food-dist (/ (sqrt (+ (pow (- x fx) 2) (pow (- y fy) 2))) *window-x*))
           (food-amount (food-amount nearest-food))
           ;(chew (/ (animal-chewing animal) *chew-ticks*))
           (predator-angle-diff (angle-diff x y px py animal-angle))
           (predator-dist (/ (sqrt (+ (pow (- x px) 2) (pow (- y py) 2))) *window-x*))
           (predator-chewing (animal-chewing nearest-predator))
           (inputs (list food-angle-diff
                         food-dist
                         food-amount
                         predator-angle-diff
                         predator-dist
                         predator-chewing)))
      (let ((outputs (run-net (animal-net animal) inputs)))
        (if *neuron-sigmoid-negatives*
            (progn
              (incf (angle animal) (* *angle-multiplier* (car outputs)))
              (setf (speed animal) (* 1.2 (cadr outputs))))
            (progn
              (incf (angle animal) (* (* 2 (- (car outputs) 1/2)) *angle-multiplier*))
              (setf (speed animal) (1- (* 2 (cadr outputs)))))))
      (call-next-method animal objects)
      (eat animal nearest-food))))
|#

(defmethod eat ((animal scavenger) (food food))
  (let* ((x (x animal))
         (y (y animal))
         (fx (x food))
         (fy (y food))
         (dist (sqrt (+ (pow (- x fx) 2) (pow (- y fy) 2)))))
    (when (not (animal-dead animal))
      (if (< (animal-chewing animal) 1)
          (when (< dist (+ 3 *food-size* *scavenger-size*))
            (stimulate-net (animal-net animal) *stimulate-amount*)
            (setf (animal-chewing animal) *chew-ticks*)
            (incf (animal-fitness animal) 1)
            (decf (food-amount food) 1)
            (when (< (food-amount food) 1)
              (reset-object food)))
          (decf (animal-chewing animal))))))

(defmethod kill ((animal scavenger))
  (setf (animal-dead animal) t)
  (setf (scavenger-dead-x animal) (x animal))
  (setf (scavenger-dead-y animal) (y animal))
  (setf (x animal) 9999)
  (setf (y animal) 9999))

(defmethod draw ((animal scavenger))
  (let* ((initial-genome-length (animal-initial-genome-length animal))
         (genes (genome-genes (net-genome (animal-net animal))))
         (num-new (- (length genes) initial-genome-length))
         (new-genes (loop for i from initial-genome-length to (1- (+ num-new initial-genome-length))
                          collect (elt genes i)))
         (new-neurons (remove-if (lambda (x) (not (eql (getf x :action) :create-neuron))) new-genes))
         (new-connections (remove-if (lambda (x) (not (eql (getf x :action) :create-connection))) new-genes))
         (rem-connections (remove-if (lambda (x) (not (eql (getf x :action) :remove-connection))) new-genes))
         (length-nn (length new-neurons))
         (length-nc (length new-connections))
         (length-rc (length rem-connections))
         (fitness (animal-fitness animal))
         (x (+ (if (animal-dead animal)
                   (scavenger-dead-x animal)
                   (x animal))
               *window-padding*))
         (y (+ (if (animal-dead animal)
                   (scavenger-dead-y animal)
                   (y animal))
               *window-padding*))
         (angle (if (animal-dead animal) 0 (angle animal)))
         (speed (if (animal-dead animal) 0 (speed animal))))
    (if (animal-dead animal)
        (if (< fitness 1)
            (gl:color 0.7 0.7 0.7)
            (gl:color 0.4 0.4 0.4))
        (if (zerop (animal-chewing animal))
            (gl:color 0.0 0.7 0.0)
            (gl:color 0.0 0.7 0.7)))
    (gl:push-matrix)
    (gl:translate x y 0)
    (gl:rotate (+ 270 (- angle)) 0 0 1)
    (gl:begin :polygon)
    ;; pring body
    (let* ((ss *scavenger-size*)
           (ssn (- *scavenger-size*))
           (length (+ (* 2 ss)
                      (abs (* 4 speed)))))
      (gl:vertex ssn ssn)
      (gl:vertex ss ssn)
      (gl:vertex 0 length))
    (gl:end)
    ;; show removed connections
    (when (< 0 length-rc)
      (gl:color 0.6 0 0)
      (dotimes (i length-rc)
        (let ((y (+ (* i 2) (* -1.5 *scavenger-size*)))
              (s *scavenger-size*)
              (sn (- *scavenger-size*)))
          (gl:begin :lines)
            (gl:vertex sn y)
            (gl:vertex s y)
          (gl:end))))
    (when (< 0 (max length-nn length-nc))
      (gl:color 0 0 0.9)
      (dotimes (i (max length-nn length-nc))
        (let* ((n (< i length-nn))
               (c (< i length-nc))
               (side (- (* 2 (if (evenp i) 1 0)) 1))
               (x (* side (+ 4 (if (< 0 side) i (1- i)))))
               (s (* 2 *scavenger-size*))
               (sn (- s)))
          (when n
            (let ((x (+ x 1))
                  (nx (- x 1))
                  (y 3)
                  (ny 0))
            (gl:begin :polygon)
              (gl:vertex nx ny)
              (gl:vertex x ny)
              (gl:vertex x y)
              (gl:vertex nx y)
            (gl:end)))
          (when c
            (gl:begin :lines)
              (gl:vertex x (+ 2 sn))
              (gl:vertex x s)
            (gl:end)))))
    (gl:pop-matrix)))
